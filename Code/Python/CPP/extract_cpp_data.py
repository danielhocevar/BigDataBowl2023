# -*- coding: utf-8 -*-
"""extract_CPP_data.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GA9APxWO8RUbNCDEYJDhpHW0p5zltuab
"""

def pocketPressureNoVisualization(imgSize=(10.66, 24),
                   playerCoordinatesProvided=False,
                   playerCoordinates=[],
                   labelNumbers=True,
                   showArrow=True,
                   fieldColor='gray',
                   endZoneColor='yellow',
                   startingPlayerDistances={},
                   recordingArrayBool=False,
                   recordingArray=[]):
  
  offense_pdf_is_none = True
  defense_pdf_is_none = True
  pdf = None
  offense_pdf=None
  defense_pdf=None
  qb_pdf = None
  x, y = np.mgrid[0:53.3:1, 0:120:1]
  locations = np.dstack((x, y))

  xCoordinateQB=playerCoordinates.loc[(playerCoordinates['pff_positionLinedUp']=='QB')]['x'].unique()[0]
  yCoordinateQB=playerCoordinates.loc[(playerCoordinates['pff_positionLinedUp']=='QB')]['y'].unique()[0]
  teamQB=playerCoordinates.loc[(playerCoordinates['pff_positionLinedUp']=='QB')]['team'].unique()[0]
  playerCoordinates['distanceFromQB']=((playerCoordinates['x']-xCoordinateQB)**2 + (playerCoordinates['y']-yCoordinateQB)**2)**(1/2)
  playerCoordinates['radiansDirection'] = playerCoordinates['dir'].astype(float).apply(math.radians) #Converts angle in degrees to radians
  playerCoordinates['xComponent']=playerCoordinates['radiansDirection'].astype(float).apply(math.cos) #Converts angle into an x and y component
  playerCoordinates['yComponent']=playerCoordinates['radiansDirection'].astype(float).apply(math.sin)
  playerCoordinates['xspeed']=playerCoordinates['xComponent']*playerCoordinates['s'] #Determines magnitude of speed by multiplying x and y component by magnitude of speed
  playerCoordinates['yspeed']=playerCoordinates['yComponent']*playerCoordinates['s']
  tableOfDefensiveCoordinates=playerCoordinates.loc[(playerCoordinates['team']!=playerCoordinates['possessionTeam']) & (playerCoordinates['team']!="football")]
  tableOfOffensiveCoordinates=playerCoordinates.loc[(playerCoordinates['team']==playerCoordinates['possessionTeam'])]

  mu_val_x=0
  mu_val_y=0
  x, y = np.mgrid[0:53.3:1, 0:120:1]
  locations = np.dstack((x, y))
  total_gaussian_Influence_Defence=0

  qb_pos_x = 0
  qb_pos_y = 0
  
  pass_rushers=playerCoordinates.loc[(playerCoordinates['pff_role']=='Pass Rush')]
  # Generate pdf's for the defensive players and the quarteback
  for index, row in playerCoordinates.iterrows():
    if row['team'] == row['defensiveTeam']:
      # Generate a defensive player pdf
      speed_Ratio=(row['s']**2)/(100)
      topLeftSMatrix=(row['distanceFromQB']+row['distanceFromQB']*speed_Ratio)/2
      bottomRightSMatrix=(row['distanceFromQB']-row['distanceFromQB']*speed_Ratio)/2
      r_matrix=[(row['xComponent'], -row['yComponent']),(row['yComponent'], row['xComponent'])];
      r_matrix=pd.DataFrame(data=r_matrix)
      s_matrix=[(topLeftSMatrix+0.00001,0), (0, bottomRightSMatrix-0.000001)]
      s_matrix=pd.DataFrame(data=s_matrix)
      inverse_r_Matrix=np.linalg.inv(r_matrix)
      multiplyingTogetherFirstTwoMatrices=r_matrix.dot(s_matrix)
      nextMatrix=multiplyingTogetherFirstTwoMatrices.dot(s_matrix)
      covariance_matrix=nextMatrix.dot(inverse_r_Matrix)
      mu_val_x=row['y']+row['yspeed']*0.5
      mu_val_y=row['x']+row['xspeed']*0.5
      mu=[mu_val_x,mu_val_y]
      player_pdf=multivariate_normal(mu,covariance_matrix).pdf(locations)
      if defense_pdf_is_none:
        # If this is the first defensive player, generate a new pdf
        defense_pdf = player_pdf
        defense_pdf_is_none = False
      else:
        # Otherwise, update the existing pdf
        defense_pdf = defense_pdf + player_pdf
    elif row['officialPosition'] == "QB":
        qb_pos_x = row['y']
        qb_pos_y = row['x']
    elif row['team']==row['possessionTeam'] and row['pff_role']=='Pass Block':
      distance_from_QB = row['distanceFromQB']
      minDistancePassRusherToQB=min(pass_rushers['distanceFromQB'])
      minDistancePassRush=1000
      for index, rowPass in pass_rushers.iterrows():
        totalDistance=((rowPass['x']-row['x'])**2+(rowPass['y']-row['y'])**2)**(1/2)
        if totalDistance<=minDistancePassRush:
          minDistancePassRush=totalDistance
          xCoordinatePassRusher=rowPass['x']
          yCoordinatePassRusher=rowPass['y']
          speedPassRusher=rowPass['s']
          dirPassRusher=rowPass['dir']
      p12=((xCoordinateQB-row['x'])**2+(yCoordinateQB-row['y'])**2)**(1/2)
      p23=((xCoordinateQB-xCoordinatePassRusher)**2+(yCoordinateQB-yCoordinatePassRusher)**2)**(1/2)
      p13=(((row['x']-xCoordinatePassRusher)**2)+((row['y']-yCoordinatePassRusher)**2))**(1/2)
      angleBetweenThreePlayers=math.acos(((p12**2) + (p13**2) - (p23**2)) / (2 * p12 * p13))
      degreesAngleBetweenThreePlayers=math.degrees(angleBetweenThreePlayers)
      angleFrom180=abs(degreesAngleBetweenThreePlayers-180)
      normalizedDistance=minDistancePassRusherToQB/(startingPlayerDistances[row['nflId']])

      speed_Ratio=(row['s']**2)/(100)
      topLeftSMatrix=(row['distanceFromQB']+row['distanceFromQB']*speed_Ratio)/2
      bottomRightSMatrix=(row['distanceFromQB']-row['distanceFromQB']*speed_Ratio)/2
      r_matrix=[(row['xComponent'], -row['yComponent']),(row['yComponent'], row['xComponent'])];
      r_matrix=pd.DataFrame(data=r_matrix)
      s_matrix=[(topLeftSMatrix+0.000001,0), (0, bottomRightSMatrix-0.000001)]
      s_matrix=pd.DataFrame(data=s_matrix)
      inverse_r_Matrix=np.linalg.inv(r_matrix)
      multiplyingTogetherFirstTwoMatrices=r_matrix.dot(s_matrix)
      nextMatrix=multiplyingTogetherFirstTwoMatrices.dot(s_matrix)
      covariance_matrix=nextMatrix.dot(inverse_r_Matrix)
      mu_val_x=row['y']+row['xspeed']*0.5
      mu_val_y=row['x']+row['yspeed']*0.5
      mu=[mu_val_x,mu_val_y]
      player_pdf=multivariate_normal(mu,covariance_matrix).pdf(locations)
      if offense_pdf_is_none:
        offense_pdf = normalizedDistance*degreesAngleBetweenThreePlayers*(player_pdf/180)
        offense_pdf_is_none = False
      else:
        offense_pdf = offense_pdf + normalizedDistance*degreesAngleBetweenThreePlayers*(player_pdf/180)
  pdf=np.array(defense_pdf)/(np.array(defense_pdf)+np.array(offense_pdf))
  qb_area = plt.Circle((qb_pos_x, qb_pos_y), 4, linewidth=2, color='w', fill=False)
  qb_pdf = multivariate_normal([qb_pos_x, qb_pos_y], [[6, 0], [0, 6]]).pdf(locations)
  pressure_pdf = np.array(qb_pdf) * np.array(pdf)
  display_pdf=np.array(qb_pdf) * np.array(offense_pdf)
  pressure_val = np.sum(np.sum(pressure_pdf, axis=1), axis=0) / np.sum(np.sum(qb_pdf, axis=1), axis=0) # 27 is the scaling factor
  pressure_val=(pressure_val-0.50)/(0.80-0.50)
  if pressure_val>=1:
    pressure_val=1
  if pressure_val<=0:
    pressure_val=0
  if playerCoordinates['event'].unique()[0]=="ball_snap":
    recordingArrayBool=True
  elif playerCoordinates['event'].unique()[0]=="pass_forward" or playerCoordinates['event'].unique()[0]=="qb_sack" or playerCoordinates['event'].unique()[0]=="qb_strip_sack":
    recordingArrayBool=False
    recordingArray.append(pressure_val)
  if recordingArrayBool==True:
    recordingArray.append(pressure_val)
  return (recordingArrayBool, recordingArray)

def extractPocketPressureArray(df1,df2, df3,df4, df5, playId, gameId):
  dictionaryValidPos={'SHOTGUN':['HB','HB-R','HB-L','TE','TE-L','TE-R','LT','RT','C','LG','RG','QB'],
                    'EMPTY':['LT','LG','C','RG','RT','QB'],
                    'SINGLEBACK':['HB','QB','LT','LG','C','TE','RG','RT','QB'],
                    'I_Form':['HB','FB','LT','LG','C','RG','RT','TE','TE-L','TE-R'],
                    'Jumbo':['HB','HB-R','HB-L', 'FB','FB-L','FB-R','LT','LG','C','RG','RT','TE','TE-L','TE-R','TE-oR','TE-iR','TE-oL','TE-oL'],
                    'Pistol':['LT','LG','C','RG','RT','TE','TE-R','TE-L','HB','HB-R','HB-L','QB'],
                    'Wildcat':['HB','QB','FB-R','FB-L','TE-L','TE-R','LG','C','RG','RT','LT','HB-R','HB-L']}
  distinctTimes=df1.loc[(df1['playId'] == playId)& (df1['gameId']==gameId) ]
  distinctTimes=distinctTimes['time'].unique() #Extracts all times associated with a particular play
  
  df1['newTime']=pd.to_datetime(df1['time'])
  testing=df1.loc[(df1['playId'] == playId) & (df1['gameId'] == gameId) ]
  timeSnap=testing.loc[testing['event']=="ball_snap"]['newTime'].unique()[0]
  testing=testing.loc[(testing['newTime']==timeSnap)]
  testingNew=pd.merge(testing,df2, on='gameId', how='left')
  testingNew=pd.merge(testingNew,df3,on=['playId','gameId'], how='left')
  testingNew=pd.merge(testingNew,df4,on='nflId', how='left')
  testingNew=pd.merge(testingNew, df5, on=['playId','gameId','nflId'], how='left')

  lMaxCoordinates=determiningMaxXAndYs(testingNew, timeSnap,dictionaryValidPos)
  startingPlayerDistances=determiningDistancesAtTimeOfSnap(testingNew, timeSnap,dictionaryValidPos)
  array_Of_Images=[]
  recordingArrayBool=False
  recordingArray=[]
  for i in distinctTimes: 
    dfForRunning=processToVisualize(df1,df2,df3,df4,df5, playId, i, gameId) #Goes through each time to process the data to visualize on the football field
    recordingArrayInfo=pocketPressureNoVisualization(playerCoordinates = dfForRunning, fieldColor='darkgreen', endZoneColor='purple', startingPlayerDistances=startingPlayerDistances, recordingArrayBool=recordingArrayBool, recordingArray=recordingArray)
    recordingArrayBool=recordingArrayInfo[0]
    recordingArray=recordingArrayInfo[1]
  return recordingArray

def determiningMaxXAndYs(tab, timeSnap, dictionaryValidPos):
  oLinePlayers=tab.loc[tab['pff_role']=='Pass Block']
  if oLinePlayers['team'].unique()[0]==oLinePlayers['homeTeamAbbr'].unique()[0] or int(oLinePlayers.quarter.unique()[0])%2==0:
    maxY=max(oLinePlayers['y'].values)+2
    minY=min(oLinePlayers['y'].values)-2
    maxX=max(oLinePlayers['x'].values)+1
    minX=0
  else:
    maxY=max(oLinePlayers['y'].values)+2
    minY=min(oLinePlayers['y'].values)-2
    maxX=120
    minX=min(oLinePlayers['x'].values)-1
  return [minX, maxX, minY, maxY]